package cloud.eppo;

import static cloud.eppo.Constants.DEFAULT_JITTER_INTERVAL_RATIO;
import static cloud.eppo.Constants.DEFAULT_POLLING_INTERVAL_MILLIS;
import static cloud.eppo.Utils.throwIfEmptyOrNull;

import cloud.eppo.api.*;
import cloud.eppo.cache.AssignmentCacheEntry;
import cloud.eppo.logging.Assignment;
import cloud.eppo.logging.AssignmentLogger;
import cloud.eppo.logging.BanditAssignment;
import cloud.eppo.logging.BanditLogger;
import cloud.eppo.ufc.dto.*;
import cloud.eppo.ufc.dto.adapters.EppoModule;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;
import java.util.Timer;
import java.util.concurrent.CompletableFuture;
import java.util.function.Consumer;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class BaseEppoClient {
  private static final Logger log = LoggerFactory.getLogger(BaseEppoClient.class);
  private final ObjectMapper mapper =
      new ObjectMapper()
          .registerModule(EppoModule.eppoModule()); // TODO: is this the best place for this?

  protected final ConfigurationRequestor requestor;

  private final IConfigurationStore configurationStore;
  private final AssignmentLogger assignmentLogger;
  private final BanditLogger banditLogger;
  private final String sdkName;
  private final String sdkVersion;
  private boolean isGracefulMode;
  private final IAssignmentCache assignmentCache;
  private final IAssignmentCache banditAssignmentCache;
  private Timer pollTimer;

  @Nullable protected CompletableFuture<Boolean> getInitialConfigFuture() {
    return initialConfigFuture;
  }

  private final CompletableFuture<Boolean> initialConfigFuture;

  // Fields useful for testing in situations where we want to mock the http client or configuration
  // store (accessed via reflection)
  /** @noinspection FieldMayBeFinal */
  private static EppoHttpClient httpClientOverride = null;

  // It is important that the bandit assignment cache expire with a short-enough TTL to last about
  // one user session.
  // The recommended is 10 minutes (per @Sven)
  /** @param host To be removed in v4. use `apiBaseUrl` instead. */
  protected BaseEppoClient(
      @NotNull String apiKey,
      @NotNull String sdkName,
      @NotNull String sdkVersion,
      @Deprecated @Nullable String host,
      @Nullable String apiBaseUrl,
      @Nullable AssignmentLogger assignmentLogger,
      @Nullable BanditLogger banditLogger,
      @Nullable IConfigurationStore configurationStore,
      boolean isGracefulMode,
      boolean expectObfuscatedConfig,
      boolean supportBandits,
      @Nullable CompletableFuture<Configuration> initialConfiguration,
      @Nullable IAssignmentCache assignmentCache,
      @Nullable IAssignmentCache banditAssignmentCache) {

    if (apiBaseUrl == null) {
      apiBaseUrl = host != null ? Constants.appendApiPathToHost(host) : Constants.DEFAULT_BASE_URL;
    }

    this.assignmentCache = assignmentCache;
    this.banditAssignmentCache = banditAssignmentCache;

    EppoHttpClient httpClient =
        buildHttpClient(apiBaseUrl, new SDKKey(apiKey), sdkName, sdkVersion);
    this.configurationStore =
        configurationStore != null ? configurationStore : new ConfigurationStore();

    // For now, the configuration is only obfuscated for Android clients
    requestor =
        new ConfigurationRequestor(
            this.configurationStore, httpClient, expectObfuscatedConfig, supportBandits);
    initialConfigFuture =
        initialConfiguration != null
            ? requestor.setInitialConfiguration(initialConfiguration)
            : null;

    this.assignmentLogger = assignmentLogger;
    this.banditLogger = banditLogger;
    this.isGracefulMode = isGracefulMode;
    // Save SDK name and version to include in logger metadata
    this.sdkName = sdkName;
    this.sdkVersion = sdkVersion;
  }

  private EppoHttpClient buildHttpClient(
      String apiBaseUrl, SDKKey sdkKey, String sdkName, String sdkVersion) {
    ApiEndpoints endpointHelper = new ApiEndpoints(sdkKey, apiBaseUrl);

    return httpClientOverride != null
        ? httpClientOverride
        : new EppoHttpClient(endpointHelper.getBaseUrl(), sdkKey.getToken(), sdkName, sdkVersion);
  }

  protected void loadConfiguration() {
    try {
      requestor.fetchAndSaveFromRemote();
    } catch (Exception ex) {
      log.error("Encountered Exception while loading configuration", ex);
      if (!isGracefulMode) {
        throw ex;
      }
    }
  }

  protected void stopPolling() {
    if (pollTimer != null) {
      pollTimer.cancel();
    }
  }

  /** Start polling using the default interval and jitter. */
  protected void startPolling() {
    startPolling(DEFAULT_POLLING_INTERVAL_MILLIS);
  }

  /**
   * Start polling using the provided polling interval and default jitter of 10%
   *
   * @param pollingIntervalMs The base number of milliseconds to wait between configuration fetches.
   */
  protected void startPolling(long pollingIntervalMs) {
    startPolling(pollingIntervalMs, pollingIntervalMs / DEFAULT_JITTER_INTERVAL_RATIO);
  }

  /**
   * Start polling using the provided interval and jitter.
   *
   * @param pollingIntervalMs The base number of milliseconds to wait between configuration fetches.
   * @param pollingJitterMs The max number of milliseconds to offset each polling interval. The SDK
   *     selects a random number between 0 and pollingJitterMS to offset the polling interval by.
   */
  protected void startPolling(long pollingIntervalMs, long pollingJitterMs) {
    stopPolling();
    log.debug("Started polling at " + pollingIntervalMs + "," + pollingJitterMs);

    // Set up polling for UFC
    pollTimer = new Timer(true);
    FetchConfigurationTask fetchConfigurationsTask =
        new FetchConfigurationTask(
            () -> {
              log.debug("[Eppo SDK] Polling callback");
              this.loadConfiguration();
            },
            pollTimer,
            pollingIntervalMs,
            pollingJitterMs);

    // We don't want to fetch right away, so we schedule the next fetch.
    // Graceful mode is implicit here because `FetchConfigurationsTask` catches and
    // logs errors without rethrowing.
    fetchConfigurationsTask.scheduleNext();
  }

  protected CompletableFuture<Void> loadConfigurationAsync() {
    CompletableFuture<Void> future = new CompletableFuture<>();

    requestor
        .fetchAndSaveFromRemoteAsync()
        .exceptionally(
            ex -> {
              log.error("Encountered Exception while loading configuration", ex);
              if (!isGracefulMode) {
                future.completeExceptionally(ex);
              }
              return null;
            })
        .thenAccept(future::complete);

    return future;
  }

  /**
   * Core evaluation method that handles validation, evaluation, and logging. This consolidates the
   * shared logic between all assignment methods. Returns evaluation details with variationValue set
   * to the result.
   */
  protected EvaluationDetails evaluateAndLog(
      String flagKey,
      String subjectKey,
      Attributes subjectAttributes,
      VariationType expectedType) {

    throwIfEmptyOrNull(flagKey, "flagKey must not be empty");
    throwIfEmptyOrNull(subjectKey, "subjectKey must not be empty");

    Configuration config = getConfiguration();

    // Check if flag exists
    FlagConfig flag = config.getFlag(flagKey);
    if (flag == null) {
      log.warn("no configuration found for key: {}", flagKey);
      return buildDefaultEvaluationDetails(
          FlagEvaluationCode.FLAG_UNRECOGNIZED_OR_DISABLED,
          "Unrecognized or disabled flag: " + flagKey,
          null);
    }

    // Check if flag is enabled
    if (!flag.isEnabled()) {
      log.info(
          "no assigned variation because the experiment or feature flag is disabled: {}", flagKey);
      return buildDefaultEvaluationDetails(
          FlagEvaluationCode.FLAG_UNRECOGNIZED_OR_DISABLED,
          "Unrecognized or disabled flag: " + flagKey,
          null);
    }

    // Check if flag type matches expected type
    if (flag.getVariationType() != expectedType) {
      log.warn(
          "no assigned variation because the flag type doesn't match the requested type: {} has type {}, requested {}",
          flagKey,
          flag.getVariationType(),
          expectedType);
      return buildDefaultEvaluationDetails(
          FlagEvaluationCode.TYPE_MISMATCH,
          String.format(
              "Flag \"%s\" has type %s, requested %s",
              flagKey, flag.getVariationType(), expectedType),
          null);
    }

    // Evaluate flag with details
    DetailedFlagEvaluationResult detailedResult =
        FlagEvaluator.evaluateFlagWithDetails(
            flag, flagKey, subjectKey, subjectAttributes, config.isConfigObfuscated());
    EvaluationDetails evaluationDetails = detailedResult.getEvaluationDetails();

    EppoValue assignedValue =
        detailedResult.getVariation() != null ? detailedResult.getVariation().getValue() : null;

    // Check if value type matches expected
    if (assignedValue != null && !valueTypeMatchesExpected(expectedType, assignedValue)) {
      log.warn(
          "no assigned variation because the flag type doesn't match the variation type: {} has type {}, variation value is {}",
          flagKey,
          flag.getVariationType(),
          assignedValue);

      // Update evaluation details with error code but keep the matched allocation and variation
      // info
      // Set variationValue to null since no valid variation can be assigned
      String variationKey =
          detailedResult.getVariation() != null ? detailedResult.getVariation().getKey() : null;
      String errorDescription =
          String.format(
              "Variation (%s) is configured for type %s, but is set to incompatible value (%s)",
              variationKey, expectedType, assignedValue.doubleValue());

      return new EvaluationDetails(
          evaluationDetails.getEnvironmentName(),
          FlagEvaluationCode.ASSIGNMENT_ERROR, // We use ASSIGNMENT_ERROR for value mismatch as it's a misconfiguration of the flag itself
          errorDescription,
          evaluationDetails.getBanditKey(),
          evaluationDetails.getBanditAction(),
          variationKey,
          assignedValue,
          evaluationDetails.getMatchedRule(),
          evaluationDetails.getMatchedAllocation(),
          evaluationDetails.getUnmatchedAllocations(),
          evaluationDetails.getUnevaluatedAllocations());
    }

    // Log assignment if applicable
    if (assignedValue != null && assignmentLogger != null && detailedResult.doLog()) {
      try {
        String allocationKey = detailedResult.getAllocationKey();
        String experimentKey =
            flagKey
                + '-'
                + allocationKey; // Our experiment key is derived by hyphenating the flag key and
        // allocation key
        String variationKey = detailedResult.getVariation().getKey();
        Map<String, String> extraLogging = detailedResult.getExtraLogging();
        Map<String, String> metaData = buildLogMetaData(config.isConfigObfuscated());

        Assignment assignment =
            new Assignment(
                experimentKey,
                flagKey,
                allocationKey,
                variationKey,
                subjectKey,
                subjectAttributes,
                extraLogging,
                metaData);

        // Deduplication of assignment logging is possible by providing an `IAssignmentCache`.
        // Default to true, only avoid logging if there's a cache hit.
        boolean logAssignment = true;
        AssignmentCacheEntry cacheEntry = AssignmentCacheEntry.fromVariationAssignment(assignment);
        if (assignmentCache != null) {
          logAssignment = assignmentCache.putIfAbsent(cacheEntry);
        }

        if (logAssignment) {
          assignmentLogger.logAssignment(assignment);
        }

      } catch (Exception e) {
        log.error("Error logging assignment: {}", e.getMessage(), e);
      }
    }

    return evaluationDetails;
  }

  private boolean valueTypeMatchesExpected(VariationType expectedType, EppoValue value) {
    boolean typeMatch;
    switch (expectedType) {
      case BOOLEAN:
        typeMatch = value.isBoolean();
        break;
      case INTEGER:
        typeMatch =
            value.isNumeric()
                // Java has no isInteger check so we check using mod
                && value.doubleValue() % 1 == 0.0;
        break;
      case NUMERIC:
        typeMatch = value.isNumeric();
        break;
      case STRING:
        typeMatch = value.isString();
        break;
      case JSON:
        typeMatch =
            value.isString()
                // Eppo leaves JSON as a JSON string; to verify it's valid we attempt to parse
                && parseJsonString(value.stringValue()) != null;
        break;
      default:
        throw new IllegalArgumentException("Unexpected type for type checking: " + expectedType);
    }

    return typeMatch;
  }

  public boolean getBooleanAssignment(String flagKey, String subjectKey, boolean defaultValue) {
    return this.getBooleanAssignment(flagKey, subjectKey, new Attributes(), defaultValue);
  }

  public boolean getBooleanAssignment(
      String flagKey, String subjectKey, Attributes subjectAttributes, boolean defaultValue) {
    try {
      EvaluationDetails details =
          evaluateAndLog(
              flagKey,
              subjectKey,
              subjectAttributes,
              EppoValue.valueOf(defaultValue),
              VariationType.BOOLEAN);
      EppoValue value = details.getVariationValue();
      return details.evaluationSuccessful() ? value.booleanValue() : defaultValue;
    } catch (Exception e) {
      return throwIfNotGraceful(e, defaultValue);
    }
  }

  public int getIntegerAssignment(String flagKey, String subjectKey, int defaultValue) {
    return getIntegerAssignment(flagKey, subjectKey, new Attributes(), defaultValue);
  }

  public int getIntegerAssignment(
      String flagKey, String subjectKey, Attributes subjectAttributes, int defaultValue) {
    try {
      EvaluationDetails details =
          evaluateAndLog(
              flagKey,
              subjectKey,
              subjectAttributes,
              EppoValue.valueOf(defaultValue),
              VariationType.INTEGER);
      EppoValue value = details.getVariationValue();
      return details.evaluationSuccessful() ? (int) value.doubleValue() : defaultValue;
    } catch (Exception e) {
      return throwIfNotGraceful(e, defaultValue);
    }
  }

  public Double getDoubleAssignment(String flagKey, String subjectKey, double defaultValue) {
    return getDoubleAssignment(flagKey, subjectKey, new Attributes(), defaultValue);
  }

  public Double getDoubleAssignment(
      String flagKey, String subjectKey, Attributes subjectAttributes, double defaultValue) {
    try {
      EvaluationDetails details =
          evaluateAndLog(
              flagKey,
              subjectKey,
              subjectAttributes,
              EppoValue.valueOf(defaultValue),
              VariationType.NUMERIC);
      EppoValue value = details.getVariationValue();
      return details.evaluationSuccessful() ? value.doubleValue() : defaultValue;
    } catch (Exception e) {
      return throwIfNotGraceful(e, defaultValue);
    }
  }

  public String getStringAssignment(String flagKey, String subjectKey, String defaultValue) {
    return this.getStringAssignment(flagKey, subjectKey, new Attributes(), defaultValue);
  }

  public String getStringAssignment(
      String flagKey, String subjectKey, Attributes subjectAttributes, String defaultValue) {
    try {
      EvaluationDetails details =
          evaluateAndLog(
              flagKey,
              subjectKey,
              subjectAttributes,
              EppoValue.valueOf(defaultValue),
              VariationType.STRING);
      EppoValue value = details.getVariationValue();
      return details.evaluationSuccessful() ? value.stringValue() : defaultValue;
    } catch (Exception e) {
      return throwIfNotGraceful(e, defaultValue);
    }
  }

  /**
   * Returns the assignment for the provided feature flag key and subject key as a {@link JsonNode}.
   * If the flag is not found, does not match the requested type or is disabled, defaultValue is
   * returned.
   *
   * @param flagKey the feature flag key
   * @param subjectKey the subject key
   * @param defaultValue the default value to return if the flag is not found
   * @return the JSON string value of the assignment
   */
  public JsonNode getJSONAssignment(String flagKey, String subjectKey, JsonNode defaultValue) {
    return getJSONAssignment(flagKey, subjectKey, new Attributes(), defaultValue);
  }

  /**
   * Returns the assignment for the provided feature flag key and subject key as a {@link JsonNode}.
   * If the flag is not found, does not match the requested type or is disabled, defaultValue is
   * returned.
   *
   * @param flagKey the feature flag key
   * @param subjectKey the subject key
   * @param defaultValue the default value to return if the flag is not found
   * @return the JSON string value of the assignment
   */
  public JsonNode getJSONAssignment(
      String flagKey, String subjectKey, Attributes subjectAttributes, JsonNode defaultValue) {
    try {
      EvaluationDetails details =
          evaluateAndLog(
              flagKey,
              subjectKey,
              subjectAttributes,
              EppoValue.valueOf(defaultValue.toString()),
              VariationType.JSON);
      EppoValue value = details.getVariationValue();
      if (details.evaluationSuccessful()) {
        String stringValue = value.stringValue();
        return parseJsonString(stringValue);
      } else {
          return defaultValue;
      }
    } catch (Exception e) {
      return throwIfNotGraceful(e, defaultValue);
    }
  }

  /**
   * Returns the assignment for the provided feature flag key, subject key and subject attributes as
   * a JSON string. If the flag is not found, does not match the requested type or is disabled,
   * defaultValue is returned.
   *
   * @param flagKey the feature flag key
   * @param subjectKey the subject key
   * @param defaultValue the default value to return if the flag is not found
   * @return the JSON string value of the assignment
   */
  public String getJSONStringAssignment(
      String flagKey, String subjectKey, Attributes subjectAttributes, String defaultValue) {
    try {
      EvaluationDetails details =
          evaluateAndLog(
              flagKey,
              subjectKey,
              subjectAttributes,
              EppoValue.valueOf(defaultValue),
              VariationType.JSON);
      EppoValue value = details.getVariationValue();
      return details.evaluationSuccessful() ? value.stringValue() : defaultValue;
    } catch (Exception e) {
      return throwIfNotGraceful(e, defaultValue);
    }
  }

  /**
   * Returns the assignment for the provided feature flag key and subject key as a JSON String. If
   * the flag is not found, does not match the requested type or is disabled, defaultValue is
   * returned.
   *
   * @param flagKey the feature flag key
   * @param subjectKey the subject key
   * @param defaultValue the default value to return if the flag is not found
   * @return the JSON string value of the assignment
   */
  public String getJSONStringAssignment(String flagKey, String subjectKey, String defaultValue) {
    return this.getJSONStringAssignment(flagKey, subjectKey, new Attributes(), defaultValue);
  }

  private JsonNode parseJsonString(String jsonString) {
    try {
      return mapper.readTree(jsonString);
    } catch (JsonProcessingException e) {
      return null;
    }
  }

  /** Internal method to get assignment with detailed evaluation information. */
  protected <T> AssignmentDetails<T> getTypedAssignmentWithDetails(
      String flagKey,
      String subjectKey,
      Attributes subjectAttributes,
      T defaultValue,
      VariationType expectedType) {

    // Convert default value to EppoValue for evaluation
    EppoValue defaultEppoValue;
    if (defaultValue == null) {
      defaultEppoValue = EppoValue.nullValue();
    } else {
      switch (expectedType) {
        case BOOLEAN:
          defaultEppoValue = EppoValue.valueOf((Boolean) defaultValue);
          break;
        case INTEGER:
          // EppoValue doesn't have valueOf(int), so convert to double first
          defaultEppoValue = EppoValue.valueOf(((Integer) defaultValue).doubleValue());
          break;
        case NUMERIC:
          defaultEppoValue = EppoValue.valueOf((Double) defaultValue);
          break;
        case STRING:
          defaultEppoValue = EppoValue.valueOf((String) defaultValue);
          break;
        case JSON:
          // Handle JsonNode by converting to string
          if (defaultValue instanceof JsonNode) {
            defaultEppoValue = EppoValue.valueOf(defaultValue.toString());
          } else {
            defaultEppoValue = EppoValue.valueOf((String) defaultValue);
          }
          break;
        default:
          defaultEppoValue = EppoValue.nullValue();
      }
    }

    EvaluationDetails details =
        evaluateAndLog(flagKey, subjectKey, subjectAttributes, defaultEppoValue, expectedType);

    EppoValue value = details.getVariationValue();
    EppoValue valueToConvert = details.evaluationSuccessful() ? value : defaultEppoValue;
    T resultValue = convertEppoValue(valueToConvert, expectedType, defaultValue);
    return new AssignmentDetails<>(resultValue, null, details);
  }

  @SuppressWarnings("unchecked")
  private <T> T convertEppoValue(EppoValue value, VariationType expectedType, T defaultValue) {
    switch (expectedType) {
      case BOOLEAN:
        return (T) Boolean.valueOf(value.booleanValue());
      case INTEGER:
        return (T) Integer.valueOf((int) value.doubleValue());
      case NUMERIC:
        return (T) Double.valueOf(value.doubleValue());
      case STRING:
      case JSON:
        return (T) value.stringValue();
      default:
        return defaultValue;
    }
  }

  private EvaluationDetails buildDefaultEvaluationDetails(
      FlagEvaluationCode code, String description, EppoValue variationValue) {
    return new EvaluationDetails(
        "Test", // Default environment name
        code,
        description,
        null, // banditKey
        null, // banditAction
        null, // variationKey
        variationValue,
        null, // matchedRule
        null, // matchedAllocation
        new ArrayList<>(), // unmatchedAllocations
        new ArrayList<>()); // unevaluatedAllocations
  }

  /**
   * Returns assignment details for a boolean flag including comprehensive evaluation information.
   */
  public AssignmentDetails<Boolean> getBooleanAssignmentDetails(
      String flagKey, String subjectKey, boolean defaultValue) {
    return this.getBooleanAssignmentDetails(flagKey, subjectKey, new Attributes(), defaultValue);
  }

  /**
   * Returns assignment details for a boolean flag including comprehensive evaluation information.
   */
  public AssignmentDetails<Boolean> getBooleanAssignmentDetails(
      String flagKey, String subjectKey, Attributes subjectAttributes, boolean defaultValue) {
    try {
      return this.getTypedAssignmentWithDetails(
          flagKey, subjectKey, subjectAttributes, defaultValue, VariationType.BOOLEAN);
    } catch (Exception e) {
      return new AssignmentDetails<>(
          throwIfNotGraceful(e, defaultValue),
          null,
          buildDefaultEvaluationDetails(
              FlagEvaluationCode.ASSIGNMENT_ERROR,
              e.getMessage(),
              EppoValue.valueOf(defaultValue)));
    }
  }

  /**
   * Returns assignment details for an integer flag including comprehensive evaluation information.
   */
  public AssignmentDetails<Integer> getIntegerAssignmentDetails(
      String flagKey, String subjectKey, int defaultValue) {
    return getIntegerAssignmentDetails(flagKey, subjectKey, new Attributes(), defaultValue);
  }

  /**
   * Returns assignment details for an integer flag including comprehensive evaluation information.
   */
  public AssignmentDetails<Integer> getIntegerAssignmentDetails(
      String flagKey, String subjectKey, Attributes subjectAttributes, int defaultValue) {
    try {
      return this.getTypedAssignmentWithDetails(
          flagKey, subjectKey, subjectAttributes, defaultValue, VariationType.INTEGER);
    } catch (Exception e) {
      return new AssignmentDetails<>(
          throwIfNotGraceful(e, defaultValue),
          null,
          buildDefaultEvaluationDetails(
              FlagEvaluationCode.ASSIGNMENT_ERROR,
              e.getMessage(),
              EppoValue.valueOf(defaultValue)));
    }
  }

  /**
   * Returns assignment details for a numeric (double) flag including comprehensive evaluation
   * information.
   */
  public AssignmentDetails<Double> getDoubleAssignmentDetails(
      String flagKey, String subjectKey, double defaultValue) {
    return getDoubleAssignmentDetails(flagKey, subjectKey, new Attributes(), defaultValue);
  }

  /**
   * Returns assignment details for a numeric (double) flag including comprehensive evaluation
   * information.
   */
  public AssignmentDetails<Double> getDoubleAssignmentDetails(
      String flagKey, String subjectKey, Attributes subjectAttributes, double defaultValue) {
    try {
      return this.getTypedAssignmentWithDetails(
          flagKey, subjectKey, subjectAttributes, defaultValue, VariationType.NUMERIC);
    } catch (Exception e) {
      return new AssignmentDetails<>(
          throwIfNotGraceful(e, defaultValue),
          null,
          buildDefaultEvaluationDetails(
              FlagEvaluationCode.ASSIGNMENT_ERROR,
              e.getMessage(),
              EppoValue.valueOf(defaultValue)));
    }
  }

  /**
   * Returns assignment details for a string flag including comprehensive evaluation information.
   */
  public AssignmentDetails<String> getStringAssignmentDetails(
      String flagKey, String subjectKey, String defaultValue) {
    return this.getStringAssignmentDetails(flagKey, subjectKey, new Attributes(), defaultValue);
  }

  /**
   * Returns assignment details for a string flag including comprehensive evaluation information.
   */
  public AssignmentDetails<String> getStringAssignmentDetails(
      String flagKey, String subjectKey, Attributes subjectAttributes, String defaultValue) {
    try {
      return this.getTypedAssignmentWithDetails(
          flagKey, subjectKey, subjectAttributes, defaultValue, VariationType.STRING);
    } catch (Exception e) {
      return new AssignmentDetails<>(
          throwIfNotGraceful(e, defaultValue),
          null,
          buildDefaultEvaluationDetails(
              FlagEvaluationCode.ASSIGNMENT_ERROR,
              e.getMessage(),
              EppoValue.valueOf(defaultValue)));
    }
  }

  /**
   * Returns assignment details for a JSON flag including comprehensive evaluation information. The
   * variation value is returned as a JsonNode.
   */
  public AssignmentDetails<JsonNode> getJSONAssignmentDetails(
      String flagKey, String subjectKey, JsonNode defaultValue) {
    return this.getJSONAssignmentDetails(flagKey, subjectKey, new Attributes(), defaultValue);
  }

  /**
   * Returns assignment details for a JSON flag including comprehensive evaluation information. The
   * variation value is returned as a JsonNode.
   */
  public AssignmentDetails<JsonNode> getJSONAssignmentDetails(
      String flagKey, String subjectKey, Attributes subjectAttributes, JsonNode defaultValue) {
    try {
      // Get the string assignment details first
      AssignmentDetails<String> stringDetails =
          this.getTypedAssignmentWithDetails(
              flagKey, subjectKey, subjectAttributes, null, VariationType.JSON);

      String jsonString = stringDetails.getVariation();
      JsonNode resultValue = defaultValue;
      if (jsonString != null) {
        JsonNode parsed = parseJsonString(jsonString);
        if (parsed != null) {
          resultValue = parsed;
        }
      }

      return new AssignmentDetails<>(
          resultValue, stringDetails.getAction(), stringDetails.getEvaluationDetails());
    } catch (Exception e) {
      String defaultValueString = defaultValue != null ? defaultValue.toString() : null;
      return new AssignmentDetails<>(
          throwIfNotGraceful(e, defaultValue),
          null,
          buildDefaultEvaluationDetails(
              FlagEvaluationCode.ASSIGNMENT_ERROR,
              e.getMessage(),
              EppoValue.valueOf(defaultValueString)));
    }
  }

  /**
   * Returns assignment details for a JSON flag including comprehensive evaluation information. The
   * variation value is returned as a JSON string.
   */
  public AssignmentDetails<String> getJSONStringAssignmentDetails(
      String flagKey, String subjectKey, String defaultValue) {
    return this.getJSONStringAssignmentDetails(flagKey, subjectKey, new Attributes(), defaultValue);
  }

  /**
   * Returns assignment details for a JSON flag including comprehensive evaluation information. The
   * variation value is returned as a JSON string.
   */
  public AssignmentDetails<String> getJSONStringAssignmentDetails(
      String flagKey, String subjectKey, Attributes subjectAttributes, String defaultValue) {
    try {
      return this.getTypedAssignmentWithDetails(
          flagKey, subjectKey, subjectAttributes, defaultValue, VariationType.JSON);
    } catch (Exception e) {
      return new AssignmentDetails<>(
          throwIfNotGraceful(e, defaultValue),
          null,
          buildDefaultEvaluationDetails(
              FlagEvaluationCode.ASSIGNMENT_ERROR,
              e.getMessage(),
              EppoValue.valueOf(defaultValue)));
    }
  }

  public BanditResult getBanditAction(
      String flagKey,
      String subjectKey,
      DiscriminableAttributes subjectAttributes,
      Actions actions,
      String defaultValue) {
    BanditResult result = new BanditResult(defaultValue, null);
    final Configuration config = getConfiguration();
    try {
      String assignedVariation =
          getStringAssignment(
              flagKey, subjectKey, subjectAttributes.getAllAttributes(), defaultValue);

      // Update result to reflect that we've been assigned a variation
      result = new BanditResult(assignedVariation, null);

      String banditKey = config.banditKeyForVariation(flagKey, assignedVariation);
      if (banditKey != null && !actions.isEmpty()) {
        BanditParameters banditParameters = config.getBanditParameters(banditKey);
        BanditEvaluationResult banditResult =
            BanditEvaluator.evaluateBandit(
                flagKey, subjectKey, subjectAttributes, actions, banditParameters.getModelData());

        // Update result to reflect that we've been assigned an action
        result = new BanditResult(assignedVariation, banditResult.getActionKey());

        if (banditLogger != null) {
          try {
            BanditAssignment banditAssignment =
                new BanditAssignment(
                    flagKey,
                    banditKey,
                    subjectKey,
                    banditResult.getActionKey(),
                    banditResult.getActionWeight(),
                    banditResult.getOptimalityGap(),
                    banditParameters.getModelVersion(),
                    subjectAttributes.getNumericAttributes(),
                    subjectAttributes.getCategoricalAttributes(),
                    banditResult.getActionAttributes().getNumericAttributes(),
                    banditResult.getActionAttributes().getCategoricalAttributes(),
                    buildLogMetaData(config.isConfigObfuscated()));

            // Log, only if there is no cache hit.
            boolean logBanditAssignment = true;
            AssignmentCacheEntry cacheEntry =
                AssignmentCacheEntry.fromBanditAssignment(banditAssignment);
            if (banditAssignmentCache != null) {
              if (banditAssignmentCache.hasEntry(cacheEntry)) {
                logBanditAssignment = false;
              }
            }

            if (logBanditAssignment) {
              banditLogger.logBanditAssignment(banditAssignment);

              if (banditAssignmentCache != null) {
                banditAssignmentCache.put(cacheEntry);
              }
            }
          } catch (Exception e) {
            log.warn("Error logging bandit assignment: {}", e.getMessage(), e);
          }
        }
      }
      return result;
    } catch (Exception e) {
      return throwIfNotGraceful(e, result);
    }
  }

  /**
   * Returns bandit action assignment with detailed evaluation information including flag evaluation
   * details and bandit action selection.
   */
  public AssignmentDetails<String> getBanditActionDetails(
      String flagKey,
      String subjectKey,
      DiscriminableAttributes subjectAttributes,
      Actions actions,
      String defaultValue) {
    final Configuration config = getConfiguration();
    try {
      // Get detailed flag assignment
      AssignmentDetails<String> flagDetails =
          getStringAssignmentDetails(
              flagKey, subjectKey, subjectAttributes.getAllAttributes(), defaultValue);

      String assignedVariation = flagDetails.getVariation();
      String assignedAction = null;

      // If we got a variation, check for bandit
      String banditKey = config.banditKeyForVariation(flagKey, assignedVariation);
      if (banditKey != null && !actions.isEmpty()) {
        try {
          BanditParameters banditParameters = config.getBanditParameters(banditKey);
          if (banditParameters == null) {
            throw new RuntimeException("Bandit parameters not found for bandit key: " + banditKey);
          }
          BanditEvaluationResult banditResult =
              BanditEvaluator.evaluateBandit(
                  flagKey, subjectKey, subjectAttributes, actions, banditParameters.getModelData());

          assignedAction = banditResult.getActionKey();

          // Log bandit assignment if needed
          if (banditLogger != null) {
            try {
              BanditAssignment banditAssignment =
                  new BanditAssignment(
                      flagKey,
                      banditKey,
                      subjectKey,
                      banditResult.getActionKey(),
                      banditResult.getActionWeight(),
                      banditResult.getOptimalityGap(),
                      banditParameters.getModelVersion(),
                      subjectAttributes.getNumericAttributes(),
                      subjectAttributes.getCategoricalAttributes(),
                      banditResult.getActionAttributes().getNumericAttributes(),
                      banditResult.getActionAttributes().getCategoricalAttributes(),
                      buildLogMetaData(config.isConfigObfuscated()));

              boolean logBanditAssignment = true;
              AssignmentCacheEntry cacheEntry =
                  AssignmentCacheEntry.fromBanditAssignment(banditAssignment);
              if (banditAssignmentCache != null) {
                if (banditAssignmentCache.hasEntry(cacheEntry)) {
                  logBanditAssignment = false;
                }
              }

              if (logBanditAssignment) {
                banditLogger.logBanditAssignment(banditAssignment);
                if (banditAssignmentCache != null) {
                  banditAssignmentCache.put(cacheEntry);
                }
              }
            } catch (Exception e) {
              log.warn("Error logging bandit assignment: {}", e.getMessage(), e);
            }
          }

          // Update evaluation details to include bandit information
          EvaluationDetails updatedDetails =
              new EvaluationDetails(
                  flagDetails.getEvaluationDetails().getEnvironmentName(),
                  flagDetails.getEvaluationDetails().getFlagEvaluationCode(),
                  flagDetails.getEvaluationDetails().getFlagEvaluationDescription(),
                  banditKey,
                  assignedAction,
                  flagDetails.getEvaluationDetails().getVariationKey(),
                  flagDetails.getEvaluationDetails().getVariationValue(),
                  flagDetails.getEvaluationDetails().getMatchedRule(),
                  flagDetails.getEvaluationDetails().getMatchedAllocation(),
                  flagDetails.getEvaluationDetails().getUnmatchedAllocations(),
                  flagDetails.getEvaluationDetails().getUnevaluatedAllocations());

          return new AssignmentDetails<>(assignedVariation, assignedAction, updatedDetails);
        } catch (Exception banditError) {
          // Bandit evaluation failed - return flag details with BANDIT_ERROR code
          log.warn(
              "Bandit evaluation failed for flag {}: {}",
              flagKey,
              banditError.getMessage(),
              banditError);
          EvaluationDetails banditErrorDetails =
              new EvaluationDetails(
                  flagDetails.getEvaluationDetails().getEnvironmentName(),
                  FlagEvaluationCode.BANDIT_ERROR,
                  "Bandit evaluation failed: " + banditError.getMessage(),
                  banditKey,
                  null, // no action assigned due to error
                  flagDetails.getEvaluationDetails().getVariationKey(),
                  flagDetails.getEvaluationDetails().getVariationValue(),
                  flagDetails.getEvaluationDetails().getMatchedRule(),
                  flagDetails.getEvaluationDetails().getMatchedAllocation(),
                  flagDetails.getEvaluationDetails().getUnmatchedAllocations(),
                  flagDetails.getEvaluationDetails().getUnevaluatedAllocations());
          return new AssignmentDetails<>(assignedVariation, null, banditErrorDetails);
        }
      }

      // No bandit - return flag details as-is
      return flagDetails;
    } catch (Exception e) {
      BanditResult defaultResult = new BanditResult(defaultValue, null);
      AssignmentDetails<String> errorDetails =
          new AssignmentDetails<>(
              defaultValue,
              null,
              buildDefaultEvaluationDetails(
                  FlagEvaluationCode.ASSIGNMENT_ERROR,
                  e.getMessage(),
                  EppoValue.valueOf(defaultValue)));
      return throwIfNotGraceful(e, errorDetails);
    }
  }

  private Map<String, String> buildLogMetaData(boolean isConfigObfuscated) {
    HashMap<String, String> metaData = new HashMap<>();
    metaData.put("obfuscated", Boolean.valueOf(isConfigObfuscated).toString());
    metaData.put("sdkLanguage", sdkName);
    metaData.put("sdkLibVersion", sdkVersion);
    return metaData;
  }

  private <T> T throwIfNotGraceful(Exception e, T defaultValue) {
    if (this.isGracefulMode) {
      log.info("error getting assignment value: {}", e.getMessage());
      return defaultValue;
    }
    throw new RuntimeException(e);
  }

  public void setIsGracefulFailureMode(boolean isGracefulFailureMode) {
    this.isGracefulMode = isGracefulFailureMode;
  }

  /**
   * Subscribe to changes to the configuration.
   *
   * @param callback A function to be executed when the configuration changes.
   * @return a Runnable which, when called unsubscribes the callback from configuration change
   *     events.
   */
  public Runnable onConfigurationChange(Consumer<Configuration> callback) {
    return requestor.onConfigurationChange(callback);
  }

  /**
   * Returns the configuration object used by the EppoClient for assignment and bandit evaluation.
   *
   * <p>The configuration object is for debugging (inspect the loaded config) and other advanced use
   * cases where flag metadata or a list of flag keys, for example, is required.
   *
   * <p>It is not recommended to use the list of keys to preload assignments as assignment
   * computation also logs its use which will affect your metrics.
   *
   * @see <a href="https://docs.geteppo.com/sdks/best-practices/where-to-assign/">Where To
   *     Assign</a> for more details.
   */
  public Configuration getConfiguration() {
    return configurationStore.getConfiguration();
  }
}
